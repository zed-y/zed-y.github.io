{"pages":[],"posts":[{"title":"","text":"Docker的使用与基本操作Dokcer 安装环境 Linux Ubuntu version 20.04 Docker 19.03v.10 Docker 安装 安装 apt 依赖包，用于通过HTTPS来获取仓库: $ sudo apt-get install \\ apt-transport-https \\ ca-certificates \\ curl \\ gnupg-agent \\ software-properties-common 添加 Docker 的官方 GPG 密钥： $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 通过搜索指纹的后8个字符，验证您现在是否拥有带有指纹的密钥。 $ sudo apt-key fingerprint 0EBFCD88 pub rsa4096 2017-02-22 [SCEA] 9DC8 5822 9FC7 DD38 854A E2D8 8D81 803C 0EBF CD88 uid [ unknown] Docker Release (CE deb) &lt;docker@docker.com&gt; sub rsa4096 2017-02-22 [S] 使用以下指令设置稳定版仓库 $ sudo add-apt-repository \\ &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) \\ stable&quot; 安装最新版本的 Docker Engine-Community 和 containerd ： $ sudo apt-get install docker-ce docker-ce-cli containerd.io 测试 Docker 是否安装成功，输入以下指令，打印出以下信息则安装成功: $ sudo docker run hello-world Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 1b930d010525: Pull complete Digest: sha256:c3b4ada4687bbaa170745b3e4dd8ac3f194ca95b2d0518b417fb47e5879d9b5f Status: Downloaded newer image for hello-world:latest Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ Docker安装完成后不能run hello-world，报错：docker: Error response from daemon: Get https://registry-1.docker.io/v2/: net/http: request canceled 的解决办法：修改Docker源： 修改或新增 /etc/docker/daemon.json # vi /etc/docker/daemon.json { &quot;registry-mirrors&quot;: [&quot;http://hub-mirror.c.163.com&quot;] } //保存后退出在执行下面语句 # systemctl restart docker.service 参考链接 https://www.runoob.com/docker/ubuntu-docker-install.html https://blog.csdn.net/BigData_Mining/article/details/87869147 Docker 使用在使用之前，为保证镜像下载速度，可以更换镜像源： Docker 修改镜像源地址 Docker的基础使用语句有以下几种：拉取镜像，上传镜像，运行容器，提交镜像，保存为tar文件，加载tar文件，Dockerfile来build镜像 拉取镜像Docker可以使用pull命令来拉去远程共有仓库中的镜像到本机使用，具体方法如下： root$ docker search tomcat 首先利用search来查找要获取的镜像名字 然后获取自己需要的镜像，以第一个的为例： root$ docker pull tomcat 默认版本为latest，如果需要特定版本，可以加:版本号，如tomcat:8 下载完成后，便可以查看本地仓库的镜像 root$ docker image ls 上传镜像当对一个官方镜像做了一个修改，成为自己的镜像后，可以选择上传到DokcerHub上，作为一个自己的独特的镜像，此处略去过程。 运行容器通过docker run命令来运行一个容器，例如下面这个例子。 root$ docker run --name Mytom -d -p 8888:8080 tomcat 上述命令中，–name为指定运行的容器的名字，方便以后管理，-d为保持后台运行，因为tomcat已启动后，便会占用此窗口来显示其日志，-p为映射端口，: 之前的端口为宿主机的端口，: 之后的端口为容器内的端口，因为容器必须要映射到主机之后才可以访问。 关于dockers run的具体参数不与解释，详情见网络资料 运行后通过docker container ps 命令来查看当前运行容器情况，加上-a参数表示查看所有容器，包括已经停止的。 则会使通过浏览器访问8888端口便会发现tomcat启动成功。 PS: 如果发现浏览器打开后报404错误，见解决方法 进入容器通过命令 docker exec -it 唯一标识 /bin/bash 来进入到容器的SHELL中进行操作,对容器内部来进行操作。 其中 唯一标识可以是容器的ID，也可以是名字，-it表示容器的STDIN(标准输入输出)处于打开状态，同时分配给其一个伪终端。 提交镜像该命令类比于push命令，只不过是将镜像只提交到本地的私有仓库中，一旦删除，便无法下载。 如下： # root$ docker commit 容器的id 镜像的名字:版本号 root$ docker commit 9f951bcb20d7 yzd/mytomcat:v1 上命令便表示将9f容器提交到yzd/mytomcat镜像，版本号为v1。 commit具体参数见https://www.runoob.com/docker/docker-commit-command.html 当再次查看镜像时便会发现多了一个镜像 保存与加载tar文件保存命令：docker save -o 输出文件 镜像名字:版本号 加载命令：docker load &lt; tar文件 重头戏–Dockerfile来build镜像指令： - FROM 定制的镜像都是基于 FROM 的镜像 - COPY 从宿主机目录中复制文件或者目录到容器里指定路径 - ADD 与COPY命令相似，只不过ADD可以解压压缩文件，还可以从URL下载网络资源，而COPY不可以 - WORKDIR 指定容器工作目录。用 WORKDIR 指定的工作目录，会在构建镜像的每一层中都存在。（WORKDIR 指定的工作目录，必须是提前创建好的）。 - RUN 在docker build 时执行后面的命令 - CMD 在docker run 时运行执行后面的命令 - ENTYRYPOINT 允许您配置将作为可执行文件运行的容器。它看起来类似于CMD，因为它还允许您使用参数指定命令。区别在于当Docker容器使用命令行参数运行时，ENTRYPOINT命令不会忽略参数。 - EXPOSE 声明镜像暴露出来的端口 - VOLUME 定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。(不常用) - ENV 设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。 - ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效。 - ONBUILD 用于延迟构建命令的执行。简单的说，就是 Dockerfile 里用 ONBUILD 指定的命令，在本次构建镜像的过程中不会执行（假设镜像为 test-build）。当有新的 Dockerfile 使用了之前构建的镜像 FROM test-build ，这是执行新镜像的 Dockerfile 构建时候，会执行 test-build 的 Dockerfile 里的 ONBUILD 指定的命令。 Dockersfile具体指令可以见菜鸟教程或官方文档 一个例子： 然后进行构建与运行 可以看到1.txt中的内容变为了2020，说明执行了RUN命令修改了其中的内容。","link":"/2021/11/14/Docker%E4%B9%8B%E6%88%91%E8%A7%81/"},{"title":"Linux SHELL编程","text":"SHELL简介 Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。 Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。 脚本的建立打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell） 下面为一个简单的脚本例子： #!/bin/bash echo &quot;Hello World!&quot; **#!**是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。 echo 命令用于向窗口输出文本。 脚本的运行 作为可执行程序 chmod +x ./test.sh # 使脚本具有执行权限 ./test.sh # 执行脚本 作为解释器函数 这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如： /bin/sh test.sh 环境变量和用户变量 shell变量可以分为两大类型：环境变量和用户定义变量。自定义变量只能在当前shell环境中生效，环境变量在整个主机的shell环境中生效。 环境变量用来定制你的shell的运行环境，保证shell命令的正确执行。 这些变量大多数在/etc/profile文件中初始化，而/etc/profile是在用户登录的时候执行的。 使用set命令查看变量 使用unset+变量名可以删除用户变量 PATH –&gt; 决定了shell将到哪些目录中寻找命令或程序 HOME –&gt; 当前用户主目录 HISTSIZE –&gt; 历史记录数 LOGNAME –&gt; 当前用户的登录名 HOSTNAME –&gt; 指主机的名称 SHELL –&gt; 前用户Shell类型 LANGUGE –&gt; 语言相关的环境变量，多语言可以修改此环境变量 MAIL –&gt; 当前用户的邮件存放目录 PS1 –&gt; 基本提示符，对于root用户是#，对于普通用户是$ PS2 –&gt; 附属提示符，默认是“&gt;” 变量的声明 bash不一定要声明变量，但有些特殊类型的变量必须要声明。 命令语法： declare [options] [name[=value]] typeset [options] [name[=value]] 常用选项： -a 声明“name”是一个数组 -f 声明“name”是一个函数 -i 声明“name”是一个整数 -r 声明“name”是只读的变量 -x 表示每一个“name”变量都可以被子进程访问到，称为全局变量 例 [root@localhost root]# declare –i age=20 [root@localhost root]# declare –rx OS=LINUX [root@localhost root]# declare –i 显示所有整型变量； [root@localhost root]# declare –x 显示所有全局变量； 变量的赋值 格式：变量名=值 注意：必须保证等号(=)前后没有空格。 例： x=6 a=&quot;hello world&quot; 变量的引用 在shell中，可以通过在变量名前加一个$符号来访问它的内容。如： a=&quot;hello world&quot; echo &quot;A is: $a&quot; 一个变量给另一个变量赋值可以写成： 变量2=$变量1 x=$i 单引号、双引号和反斜杠的使用 使用双引号可引用除字符$、`(反引号)、\\外的任意字符或字符串。对大多数的元字符（包括*）都将按字面意思处理。 如果用双引号（“”）将值括起来，则允许使用$符对变量进行替换。字符串通常都被放在双引号中，以防止它们被空白字符分开。 如果用单引号‘’将值括起来，则不允许有变量替换，而不对它做shell解释。 反斜杠（\\）用来去除某些字符的特殊含义并把它们按字面意思处理，其中就包括$。 实例 输入命令 可以使用read命令来将用户的输入赋值给一个shell变量中。 语法：read [options] variable-list 常用选项： -a name 把词读入到name数组中去。 -e 把一整行读入到第一个变量中，其余的变量均为null。 -n 在输出echo后的字符串后，光标仍然停留在同一行。 -p prompt 如果是从终端读入数据则显示prompt字符串。 读入的一行输入由许多词组成，他们是用空格（或者制表符，或shell环境变量IFS的值）分隔开的。 如果这些词的数量比列出的变量的数量多，则把余下的所有词赋值给最后一个变量。如果列出的变量的数量多于输入的词的数量，这多余的变量的值被设置为null。 通常情况下，在用户按下回车键时，read命令结束。 由于read命令提供了-p参数，允许在read命令行中直接指定一个提示。 #!/bin/bash read -p &quot;Enter your name:&quot; name echo &quot;hello $name, welcome to my program&quot; exit 0 在read命令行中也可以不指定变量.如果不指定变量，那么read命令会将接收到的数据放置在环境变量REPLY中。 计时输入. 使用read命令存在着潜在危险。脚本很可能会停下来一直等待用户的输入。如果无论是否输入数据脚本都必须继续执行，那么可以使用-t选项指定一个计时器。-t选项指定read命令等待输入的秒数。当计时满时，read命令返回一个非零退出状态; #!/bin/bash if read -t 5 -p &quot;please enter your name:&quot; name then echo &quot;hello $name ,welcome to my script&quot; else echo &quot;sorry,too slow&quot; fi exit 0 默读（输入不显示在监视器上） 有时会需要脚本用户输入，但不希望输入的数据显示在监视器上。典型的例子就是输入密码，当然还有很多其他需要隐藏的数据。 -s选项能够使read命令中输入的数据不显示在监视器上（实际上，数据是显示的，只是 read命令将文本颜色设置成与背景相同的颜色）。 #!/bin/bash read -s -p &quot;Enter your password:&quot; pass echo &quot;your password is $pass&quot; exit 0 echo命令 echo命令的功能是在显示器上显示一段文字，一般起到一个提示的作用。 该命令的一般格式为： echo [-ne][字符串]或 echo [--help][--version] 说明：echo会将输入的字符串送往标准输出。输出的字符串间以空白字符隔开, 并在最后加上换行号。 参数：-n 不要在最后自动换行 -e 若字符串中出现以下字符，则特别加以处理，而不会将它当成一般文字输出： \\a 发出警告声； \\b 删除前一个字符； \\c 最后不加上换行符号； \\f 换行但光标仍旧停留在原来的位置； \\n 换行且光标移至行首； \\r 光标移至行首，但不换行； \\t 插入tab； \\v 与\\f相同； \\\\ 插入\\字符； \\nnn 插入nnn（八进制）所代表的ASCII字符； 例 $ echo -e &quot;a\\tb\\tc\\nd\\te\\tf&quot; a b c d e f 上例运用 \\t 来区隔 abc 还有 def ，以及用 \\n 将 def 换至下一行。 $ echo -ne &quot;a\\tb\\tc\\nd\\te\\bf\\a&quot; a b c d f 因为 e 字母后面是删除键（\\b），因此输入结果就没有e了。 算数比较运算符号 | 含义-|-|--eq | 等于-ge | 大于等于-le | 小于等于-ne | 不等于-gt | 大于-lt | 小于 if语句 语句结构 for语句 语法： for 变量 in 列表 do 操作 done 例 while语句 语法： while 表达式 do 操作 done 例 until语句 语法 until 表达式 do 操作 done 例 case语句 语法 case 字符串 in 值1|值2) 操作 ;; 值3|值4) 操作 ;; … 值5|值6) 操作 ;; esac 例 break和continue语句 break命令使得程序跳出for、while、until循环，执行done后面的语句，这样就永久终止了循环。 continue命令使得程序跳到done，这使得循环条件被再次求值，从而开始新的一次循环，循环变量取循环列表中的下一个值。 无论哪种情况，循环体中在这两条命令后的语句都没有执行。 break命令和continue命令常作为条件语句的一部分来使用。 let命令 let可以用来计算算术表达式的值。如果表达式中有空格或者特殊字符，则应将表达式括在双引号中。 命令语法：let express-list 如果最后的表达式取值为0，let命令返回1；否则返回0。 例 [root@localhost root]# let “x=6” “y = 9”“z = 16” [root@localhost root]# let t=x+y [root@localhost root]# echo “t= $t” t= 15 [root@localhost root]# let A=2**x B=y*z [root@localhost root]# echo “A=$A B=$B” A=64 B=144 $((expression))扩展 命令语法：$((expression)) shell计算expression并用其计算结果代替$((expression))。这个语法类似于命令替换所用的语法“$(…)”，并将执行相同的功能。可将$((expression))作为参数传递给命令或者放置在命令行上任何数字位置上。 不需要在expression中的变量名称前加上$符号。 例 #!/bin/bash echo -n &quot;How old are you? &quot; read age echo &quot;Wow, in $((100-age)) years, you'll be 100! &quot; [root@localhost root]# age_check How old are you? 20 Wow, in 80 years, you'll be 100! expr命令 expr命令将它的参数当作一个表达式来求值。 命令语法：expr args 功能：计算表达式的参数‘args’的值，并返回它的值到标准输出。 常见用法：x=expr $x + 1 反引号(``)字符使x取值为命令expr $x + 1的执行结果。也可以用语法$()替换反引号``。 例 [root@localhost root]# a1=5 [root@localhost root]# a1=$( expr $a1 + 1 ) [root@localhost root]# echo $var1 6 [root@localhost root]# var1=$( expr $a1 \\* $a1 ) [root@localhost root]# echo $a1 36 [root@localhost root]# echo $( expr $a1 / 4 ) 9 [root@localhost root]# echo $( expr $var1 % 10 ) 6 参考资料SHELL学习 Shell编程.ppt","link":"/2021/11/14/LinuxShell%E7%BC%96%E7%A8%8B/"},{"title":"Hello World test","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/11/14/hello-world/"}],"tags":[{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"fresh","slug":"fresh","link":"/tags/fresh/"}],"categories":[{"name":"test","slug":"test","link":"/categories/test/"}]}