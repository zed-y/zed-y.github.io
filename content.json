{"pages":[],"posts":[{"title":"1184-公交站间的距离","text":"1184:公交站间的距离题目介绍 解题思路 这是一道简单的题 由于公交车只能顺时针或逆时针移动，而且所有点的移动顺序是固定的，例如从1到3的顺序就只有1，2，3或是倒着走，因为其他方式的路程无疑会更长 所以只需要计算全部路程的长度和其顺序走或逆序走的路程数，然后选择较小的数值就是最短距离 参考代码12345678910111213141516171819202122class Solution { public int distanceBetweenBusStops(int[] distance, int start, int destination) { int sum = 0; int part1 = 0; if(start &gt; destination){ int tmp = start; start = destination; destination = tmp; } for(int i = 0; i &lt; distance.length; i++){ sum += distance[i]; } for(int i = start; i &lt; destination; i++){ part1 += distance[i]; } if(sum - part1 &lt; part1){ return sum-part1; }else{ return part1; } }} 简单的一题！！！[","link":"/2022/07/24/1184/"},{"title":"2299-强密码检验器II","text":"2299. 强密码检验器 II思路(Java)首先设置一个flag数组，表示第2-5项是否满足 首先判断长度，小于8直接return false 遍历字符串，将其中第2-5个条件进行判断，只要有满足条件的那么f对应的flag[i]直接设为1，然后下次就不再需要进行此次判断（通过flag的值是否为0进行判断，如果为0，那么就继续进行判断，如果为1，那么就已存在满足条件的值，跳过即可） 最后一个条件，在遍历过程中，只要存在两个相同的连续字符，直接返回return false，节约时间 参考代码123456789101112131415161718192021222324252627282930313233public boolean strongPasswordCheckerII(String password) { int len = password.length(); int[] flag = new int[4]; char[] str = password.toCharArray(); if(len &lt; 8){ return false; } for(int i = 0; i &lt; len; i++){ if(flag[0] == 0 &amp;&amp; str[i] &gt;= 'a' &amp;&amp; str[i] &lt;= 'z'){ flag[0] = 1; } if(flag[1] == 0 &amp;&amp; str[i] &gt;= 'A' &amp;&amp; str[i] &lt;= 'Z'){ flag[1] = 1; } if(flag[2] == 0 &amp;&amp; str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9'){ flag[2] = 1; } // 1! 2@ 3# 4$ 5% 6^ 7&amp; 8* 9( 10) 11- 12+ if(flag[3] == 0 &amp;&amp; (str[i] == '!' || str[i] == '@' || str[i] == '#' || str[i] == '$' || str[i] == '%' || str[i] == '^' || str[i] == '&amp;' || str[i] == '*' || str[i] == '(' || str[i] == ')' || str[i] == '-' || str[i] == '+')){ flag[3] = 1; } if(i+1 &lt; len &amp;&amp; str[i] == str[i+1]){ return false; } } if(flag[0] == 1 &amp;&amp; flag[1] == 1 &amp;&amp; flag[2] == 1 &amp;&amp; flag[3] == 1){ return true; }else{ return false; } }","link":"/2023/01/19/2299.%20%E5%BC%BA%E5%AF%86%E7%A0%81%E6%A3%80%E9%AA%8C%E5%99%A8%20II/"},{"title":"2404. 出现最频繁的偶数元素","text":"2404. 出现最频繁的偶数元素题目 给你一个整数数组 nums ，返回出现最频繁的偶数元素。如果存在多个满足条件的元素，只需要返回 最小 的一个。如果不存在这样的元素，返回 -1 。 思路 最终返回元素条件如下： 必须是偶数(num % 2 == 0) 出现次数最多 出现次数最多中值最小 解答代码 ans代表出现次数 resNum表示最终元素 123456789101112131415161718192021222324public int mostFrequentEven(int[] nums) { int res[] = new int[100001]; int ans = -1; int resNum = 100001; for(int i = 0; i &lt; nums.length; i++){ if(nums[i] % 2 == 0){ res[nums[i]]++; if(res[nums[i]] &gt; ans){ ans = res[nums[i]]; resNum = nums[i]; } if(res[nums[i]] == ans){ ans = res[nums[i]]; if(nums[i] &lt; resNum){ resNum = nums[i]; } } } } if(ans == -1){ return -1; } return resNum;}","link":"/2023/04/13/2404/"},{"title":"592.分数加减运算","text":"592. 分数加减运算*难度中等** 题目描述 解题思路 根据分数的计算方法，使用最原始的方法进行计算，最后进行化简即可 那么最原始的方法就是根据以下公式 那么，设计所需要做的就是： 先将给定的字符串按照要求提出分子和分母并将其转化为整数， 将给定的“+”和减号“-”带入分子之中，即加号则分子为正，减号则分子为负 获取分母乘积之和 将分子*分母乘积之和/分母，并获得分子相加之和 通过最大公约数进行化简，得出最终结果 参考代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495class Solution { //求取最大公约数 public int gcd(int x, int y){ if(y != 0){ return gcd(y, x%y); }else{ return x; } } // i 分子，j 分母，k 符号 public String fractionAddition(String expression) { // 用于计算最后一项，即j+1，保证存在 expression = expression + &quot;+&quot;; int len = expression.length(); //存储分母 int[] down = new int[11]; //存储分子 int[] up = new int[11]; // 分母乘积之和 int sum = 1; int cnt = 0; //Set&lt;Integer&gt; down = new HashSet&lt;&gt;(); int i = 0, j = 0, k = 0; int flag = 0; // 开头有无减号，分类讨论 if(expression.charAt(0) == '-'){ i = 1; j = 3; k = 0; }else{ i = 0; j = 2; k = 3; flag = 1; } int num1 = 0, num2 = 1; while( i &lt; len &amp;&amp; j &lt; len &amp;&amp; k &lt; len){ // 获取符号 char ch = ' '; if(flag == 1){ ch = '+'; k = -1; flag = 0; }else{ ch = expression.charAt(k); } //System.out.println(&quot;---&quot;+expression.substring(i+1,i+2)); //如果分子为10，占据2个长度，需要进行判断并将i+1, j+1, k+1保证后续循环还能继续找到对应位置 if(expression.charAt(i+1) != '/'){ num1 = 10; i++; j++; k++; }else{ num1 = Integer.parseInt(expression.substring(i, i + 1)); } //System.out.println(&quot;j+1: &quot;+expression.charAt(j+1)); // 分母同理。不过要注意最后于一项 if(expression.charAt(j+1) != '+' &amp;&amp; expression.charAt(j+1) != '-'){ num2 = 10; i++; j++; k++; }else { num2 = Integer.parseInt(expression.substring(j, j + 1)); } if(ch == '-'){ num1 = 0-num1; } //out.println(&quot;num1: &quot;+num1); //System.out.println(&quot;num2: &quot;+num2); up[cnt] = num1; down[cnt++] = num2; sum = sum * num2; //dwon.add(num2); // 加4获得下一项对应位置 i = i+4; j = j+4; k = k+4; } // 分子相加之和 int resUp = 0; for(int a = 0; a &lt; cnt; a++){ resUp += up[a] * (sum / down[a]); } //System.out.println(&quot;---&quot;+sum); //System.out.println(&quot;---&quot;+resUp); // 获取最大公约数 int g = gcd(resUp, sum); if(g &lt; 0) g = 0-g; return resUp/g + &quot;/&quot; + sum/g; }} PS: 不一定最好的,因为做完的时候已经23:57了~_~每日一图","link":"/2022/07/27/592/"},{"title":"Git命令","text":"Git使用 git init 初始化仓库文件夹，自动生成.git文件夹 git add 文件名 将目的文件添加到暂存区 git add . 表示将当前路径下所有文件均添加到暂存区 git commit -m “注释” 将暂存区文件提交到本地仓库当前分支中 git status 可以查看当前暂存区文件，以及文件修改后是否添加到暂存区，未添加则会显示为红色，已添加则会显示为绿色 git push 将本地仓库push到远程仓库当前分支中 [","link":"/2022/07/26/Git%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"","text":"TESTThis is a test！Time: 2023/01/01","link":"/2023/04/13/TEST/"},{"title":"Hello World test","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/04/13/hello-world/"},{"title":"","text":"title:国内新版Bing聊天使用toc: Truetag: Bing, ChatGPTcategory: 浏览器date: 2023-02-14 # 国内新版Bing聊天使用在不采取科学上网的前提下，使用第三方插件拦截国内bing.com自动跳转cn.bing.com前提条件：已经获得使用bing聊天资质浏览器：Edge （v110）步骤 下载edge扩展 Gooreplacer 重新输入bing.com/new ,点击下方任意问题中的一个即可成功跳转","link":"/2023/04/13/%E5%9B%BD%E5%86%85%E6%96%B0%E7%89%88Bing%E8%81%8A%E5%A4%A9%E4%BD%BF%E7%94%A8/"}],"tags":[{"name":"Java,Easy","slug":"Java-Easy","link":"/tags/Java-Easy/"},{"name":"Java,Medium","slug":"Java-Medium","link":"/tags/Java-Medium/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"fresh","slug":"fresh","link":"/tags/fresh/"}],"categories":[{"name":"Leetcode","slug":"Leetcode","link":"/categories/Leetcode/"},{"name":"LeetCode","slug":"LeetCode","link":"/categories/LeetCode/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"test","slug":"test","link":"/categories/test/"}]}