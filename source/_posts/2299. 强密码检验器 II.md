---
title: 2299-强密码检验器II
toc: True
tag: Java,Easy
category: LeetCode
date: 2023-01-19
---

# [2299. 强密码检验器 II](https://leetcode.cn/problems/strong-password-checker-ii/)

### 思路(Java)

首先设置一个flag数组，表示第2-5项是否满足

1. 首先判断长度，小于8直接return false
2. 遍历字符串，将其中第2-5个条件进行判断，只要有满足条件的那么f对应的flag[i]直接设为1，然后下次就不再需要进行此次判断（通过flag的值是否为0进行判断，如果为0，那么就继续进行判断，如果为1，那么就已存在满足条件的值，跳过即可）
3. 最后一个条件，在遍历过程中，只要存在两个相同的连续字符，直接返回return false，节约时间

### 参考代码

```Java
public boolean strongPasswordCheckerII(String password) {
        int len = password.length();
        int[] flag = new int[4];
        char[] str = password.toCharArray();
        if(len < 8){
            return false;
        }
        for(int i = 0; i < len; i++){
            if(flag[0] == 0 && str[i] >= 'a' && str[i] <= 'z'){
                flag[0] = 1;
            }
            if(flag[1] == 0 && str[i] >= 'A' && str[i] <= 'Z'){
                flag[1] = 1;
            }
            if(flag[2] == 0 && str[i] >= '0' && str[i] <= '9'){
                flag[2] = 1;
            }
            // 1! 2@ 3# 4$ 5% 6^ 7& 8* 9( 10) 11- 12+
            if(flag[3] == 0 && (str[i] == '!' || str[i] == '@' || str[i] == '#' || str[i] == '$' 
                || str[i] == '%' || str[i] == '^' || str[i] == '&' || str[i] == '*' || str[i] == '(' 
                || str[i] == ')' || str[i] == '-' || str[i] == '+')){
                    flag[3] = 1;
            }
            if(i+1 < len && str[i] == str[i+1]){
                return false;
            }
        }
        if(flag[0] == 1 && flag[1] == 1 && flag[2] == 1 && flag[3] == 1){
            return true;
        }else{
            return false;
        }
    }
```

